<form *ngIf="pokemon" (ngSubmit)="onSubmit()" #pokemonForm="ngForm"> <!-- si on a bien un pokémon avec un identifiant valide avec *ngIf, à ce moment là on mets en place le formulaire. On lève l'évènemetn avec ngSubmit, quand l'utilisateur va soumettre notre formulaire, on va déclencher la méthode onSubmit().
  Grâce à la diése on déclare une variable référencée dans le template #pokemonForm et on attribut dans cette variable le résultat de la directive ngForm (cette drective ngForm déclare la variable pokemonForm directement dans le template et écrasera un peu le comportement par défaut alors que normalement on aurait une variable référencée vers mon élément du DOM <form>). 
  Cette variable référencée pokemonForm va devenir un objet géré par Angular avec plus d'informations qu'une simple balise HTML5. ((On peut affecter le résultat de la directive ngForm à une variable référencée dans le template)) -->
    <div class="row">
      <div class="col s8 offset-s2">
        <div class="card-panel">
    
          <!-- Pokemon name -->
          <div class="form-group">
            <label for="name">Nom</label>
            <!-- on declare un champ de type text avec une classe de matériels CSS et on lui donne un identifiant // required et pattern sont des règles de validation, required rend le champ obligatoire et pattern définit un pattern d'expressions régulières, l'expression qu'on va passer en saisie devra matcher avec une chaine de caractères qui devra contenir des lettres 
            de a à z en minuscules et/ou en majuscules et les accents indiqués à la suite. Ensuite on indique un quantifieur d'expressions régulières c'est à dire que nous voulons une succession de 1 à 25 lettres (et pas autre chose: permit par l'accent circonflexe au debut et le dollar à la fin de l'expression régulière). L'accent circonflexe au début permet de préciser une valeur de départ pour notre chaine de caractères.-->
            <input type="text" class="form-control" id="name" 
                    required
                    pattern="^[a-zA-Z0-9àéèç]{1,25}$"
                   [(ngModel)]="pokemon.name" name="name"
                   #name="ngModel">
            <!-- Grâce aux parenthèses dans les crochets pour ngModel ça nous permet de mettre en place une liaison des données bidirectionnelle. Les [] permettent de pousser des données de la classe du composant vers le template et les () qui est la syntaxe de liaison d'évènements, c'est à dire pour remonter les évènements du template du composant vers sa classe-->
            <!-- Quand l'utilisateur va modifier le nom d'un pokémon (pokemon.name) on sera informé de ça côté composant et côté composant si on pilote notre pokémon et son nom, automatiquement la vue aussi se mettra à jour-->
            <!-- Le résultat de ngModel, qui en interne pour Angular est un objet métier qui va représenter un champ du formulaire notamment son état de validité, sera attribué directement à la variable référencée dans le template #name-->
            <div [hidden]="name.valid || name.pristine" 
                  class="card-panel red accent-1">
                  Le nom du pokémon est requis (1-25).
            </div>
            <!-- On va pouvoir binder (lier) la propriété hidden et l'élément qui va afficher le message d'erreur à l'utilisateur pour pouvoir le cacher, masquer-->
            <!-- avec [hidden]="name.valid on dit que si le champ du formulaire représenté par ngModel et attribué à #name est valide on masque l'élément en dessous ou alors || on va attendre que l'utilisateur intéragisse avec le champ au moins une fois grâce à .pristine pour afficher l'élément qui lui afficher le message d'erreur-->
          </div>
    
          <!-- Pokemon hp -->
          <div class="form-group">
            <label for="hp">Point de vie</label>
            <input type="number" class="form-control" id="hp"
                    required
                    pattern="^[0-9]{1,3}$"
                   [(ngModel)]="pokemon.hp" name="hp"
                   #hp="ngModel">
             <div [hidden]="hp.valid || hp.pristine"
                   class="card-panel red accent-1">
                   Les points de vie du pokémon sont compris entre 0 et 999.
             </div>
          </div>
    
          <!-- Pokemon cp -->
          <div class="form-group">
            <label for="cp">Dégâts</label>
            <input type="number" class="form-control" id="cp"
                    required
                    pattern="^[0-9]{1,2}$"
                   [(ngModel)]="pokemon.cp" name="cp"
                   #cp="ngModel">
             <div [hidden]="cp.valid || cp.pristine"
                   class="card-panel red accent-1">
                   Les dégâts du pokémon sont compris entre 0 et 99.
             </div>
          </div>
    
          <!-- Pokemon types -->
          <form class="form-group">
            <label for="types">Types</label>
            <p *ngFor="let type of types"> <!-- *ngFFor construit un champ de type checkbob pour chaque type que l'utilisateur  peut sélectionner grâce à la bouche for : let type of types. Il y aura tout les types pour que l'utilsateur puisse choisir, cocher ou décocher des éléments-->
              <label>
                <!-- champ input de type checkbok construit par *ngFor // obliger de rajouter un titre à l'input pour ne pas avoir d'erreur-->
                <input title="inputCheckbox"
                  type="checkbox"
                  class="filled-in"
                  id="{{ type }}"
                  [value]="type" 
                  [checked]="hasType(type)"
                  [disabled]="!isTypesValid(type)"
                  (change)="selectType($event, type)"/>
                  <!-- On retrouve la [value]valeur qui va être le type associé à la checkbox. On [checked]coche notre case grâce à la méthode hasType(), si l'utilisateur veut éditer Salamèche on va cocher le type feu automatiquement, et si Salamèche a pas les autres types, hasType() va nous renvoyer false et donc la case à cocher sera vide
                  On [disabled]désactive toutes les cases à cocher si l'utilissateur n'a pas respecter toutess les règles de validation c'est à dire que les types ne sont pas valide. Si l'utilisateur a déjà sélectionné 3 champs, on va freezer tout le reste des checkbox car il ne peut pas ajouter 4 types et 
                  inversement si il n'a qu'un type associé au pokémon on va freezer cette checkbox pour pas qu'il puisse l'enlever pour qu'il y en est toujours entre 1 et 3 types et que sa fourchette du nombre de types pour le pookémon soit valide.
                  On écoute l'évènemetn (change) donc je coche, je décoche, on lui associe la methode selectType(), et on lui passe un $event pour savoir si la case est cochée ou décochée pour savoir de quel type on est en train de parler.-->
                <span [attr.for]="type">
                  <div class="{{ type | pokemonTypeColor }}"> <!--On retrouve ensuite du code TypeScript avec notre pipe pour colorer dans le formulaire les différents types (rouge pour le feu, bleu pour l'eau, jaune pour l'électricité etc..).-->
                    {{ type }}
                  </div>
                </span>
              </label>
            </p>
          </form>
    
          <!-- Submit button -->
          <div class="divider"></div>
          <div class="section center">
            <button type="submit"
              class="waves-effect waves-light btn"
              [disabled]="!pokemonForm.form.valid">
              Valider</button>
          </div>
    
        </div>
      </div>
    </div>
  </form>
  <h3 *ngIf="!pokemon" class="center">Aucun pokémon à éditer...</h3> <!-- si on a une URL qui n'a aucun sens avec un identifiant qui n'existe pas , on affichera un petit message comme quoi il n'y a aucun pokémon a éditer-->
